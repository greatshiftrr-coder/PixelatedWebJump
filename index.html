<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixelated Web Jump</title>
    <style>
        * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { 
            image-rendering: pixelated; image-rendering: crisp-edges;
            width: 100vw; height: auto; max-height: 100vh; outline: none; 
            background: #222;
        }
        #fileInput { display: none; }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept="image/*">
    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const WIDTH = 160, HEIGHT = 144;
        canvas.width = WIDTH; canvas.height = HEIGHT;

        const levelColors = ['#4a90e2', '#2ecc71', '#f1c40f', '#e67e22', '#9b59b6', '#34495e'];
        const skinOptions = ['#FFCC00', '#00FFCC', '#FF00FF', '#FFFFFF', '#FF5555', '#55FF55'];
        
        let gameState = 'MENU'; 
        let score = 0, levelFlash = 0, musicEnabled = true;
        let isNewRecord = false, recordFlash = 0, combo = 1, comboTimer = 0;
        let leaderboard = JSON.parse(localStorage.getItem('pixelJumpBoard')) || [0,0,0,0,0];
        let playerColor = localStorage.getItem('pixelJumpColor') || '#FFCC00';
        let playerImg = null;
        let savedImg = localStorage.getItem('pixelJumpImg');
        if (savedImg) { playerImg = new Image(); playerImg.src = savedImg; }

        // --- AUDIO ENGINE ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        let bgmInterval = null;

        function playSound(f1, f2, type='square', vol=0.04) {
            if (!musicEnabled || audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.type = type;
            osc.frequency.setValueAtTime(f1, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(f2, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }

        function startBGM() {
            if (bgmInterval) return;
            const playNote = (freq, time) => {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.value = freq;
                g.gain.setValueAtTime(0.015, time);
                g.gain.exponentialRampToValueAtTime(0.0001, time + 0.2);
                osc.connect(g); g.connect(audioCtx.destination);
                osc.start(time); osc.stop(time + 0.2);
            };
            bgmInterval = setInterval(() => {
                if (!musicEnabled || gameState !== 'PLAYING') return;
                let now = audioCtx.currentTime;
                [261, 329, 392, 523].forEach((n, i) => playNote(n, now + (i * 0.25)));
            }, 1000);
        }

        let frameCount = 0, gameSpeed = 1.8;
        const GROUND_Y = 120;
        let player = { x: 25, y: 100, drawW: 10, drawH: 10, vy: 0, jumpCount: 0 };
        let obstacles = [], particles = [], clouds = [], trail = [], hills = [];

        // Initialize Backgrounds
        for(let i=0; i<3; i++) clouds.push({ x: Math.random()*WIDTH, y: 10+Math.random()*30, speed: 0.1+Math.random()*0.2 });
        for(let i=0; i<5; i++) hills.push({ x: i * 40, w: 30+Math.random()*20, h: 15+Math.random()*15 });

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                    life: 1.0, color: color
                });
            }
        }

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => { playerImg = img; localStorage.setItem('pixelJumpImg', ev.target.result); };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        function saveScore(s) {
            leaderboard.push(s); leaderboard.sort((a, b) => b - a);
            leaderboard = leaderboard.slice(0, 5);
            localStorage.setItem('pixelJumpBoard', JSON.stringify(leaderboard));
        }

        function resetGame() {
            score = 0; obstacles = []; particles = []; trail = [];
            isNewRecord = false; recordFlash = 0; combo = 1; comboTimer = 0;
            player.y = 100; player.vy = 0; player.jumpCount = 0;
            gameSpeed = 1.8; gameState = 'PLAYING'; frameCount = 0;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            startBGM();
        }

        function update() {
            clouds.forEach(c => {
                c.x -= c.speed;
                if(c.x < -30) { c.x = WIDTH + 10; c.y = 10 + Math.random()*30; }
            });

            if (gameState === 'PLAYING') {
                frameCount++;
                if (comboTimer > 0) comboTimer--; else combo = 1;
                
                // Parallax Hills
                hills.forEach(h => {
                    h.x -= (gameSpeed * 0.2);
                    if (h.x + h.w < 0) h.x = WIDTH;
                });

                player.vy += 0.25; player.y += player.vy;
                player.drawW += (10 - player.drawW) * 0.2;
                player.drawH += (10 - player.drawH) * 0.2;

                if (score >= 50) {
                    trail.push({x: player.x, y: player.y, w: player.drawW, h: player.drawH, hue: (frameCount * 5) % 360});
                    if (trail.length > 8) trail.shift();
                }

                if (player.y + 10 > GROUND_Y) {
                    if (player.vy > 1.5) { 
                        player.drawW = 15; player.drawH = 6; 
                        createParticles(player.x + 5, GROUND_Y, '#fff', 5);
                    }
                    player.y = GROUND_Y - 10; player.vy = 0; player.jumpCount = 0;
                }

                if (frameCount % Math.max(45, 90 - Math.floor(score * 1.5)) === 0) 
                    obstacles.push({ x: WIDTH, y: GROUND_Y - 10, w: 8, h: 10, passed: false });

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    let o = obstacles[i];
                    o.x -= gameSpeed;

                    // Collision Check
                    if (player.x < o.x + o.w && player.x + 10 > o.x &&
                        player.y < o.y + 10 && player.y + 10 > o.y) {
                        gameState = 'GAMEOVER';
                        playSound(300, 50, 'sawtooth', 0.1);
                        createParticles(player.x+5, player.y+5, '#e91e63', 15);
                        saveScore(score);
                    }

                    // Scoring & Close Call Multiplier
                    if (!o.passed && o.x + o.w < player.x) {
                        o.passed = true;
                        let clearance = player.y + 10 - o.y;
                        if (clearance < 5 && clearance > -15) {
                            combo++; comboTimer = 60;
                            playSound(500, 1000, 'sine', 0.05);
                        }
                        score += (1 * combo);
                        gameSpeed += 0.04;
                        if (score % 10 === 0) { levelFlash = 10; playSound(400, 800, 'sine'); }
                        
                        // High Score Check
                        if (score > leaderboard[0] && !isNewRecord && leaderboard[0] > 0) {
                            isNewRecord = true; recordFlash = 90;
                            playSound(800, 1200, 'triangle', 0.1);
                        }
                    }

                    if (o.x < -20) obstacles.splice(i, 1);
                }
            }
            if(levelFlash > 0) levelFlash--;
            if(recordFlash > 0) recordFlash--;
            particles.forEach((p, i) => { 
                p.x += p.vx; p.y += p.vy; p.life -= 0.03; 
                if (p.life <= 0) particles.splice(i, 1); 
            });
            draw();
            requestAnimationFrame(update);
        }

        function drawText(text, x, y, size = 8, color = "#fff", align = "center") {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            ctx.font = `${size}px monospace`;
            ctx.fillStyle = color; ctx.textAlign = align;
            ctx.fillText(text, Math.round(x), Math.round(y));
            ctx.restore();
        }

        function draw() {
            let levelIdx = Math.min(Math.floor(score / 10), levelColors.length - 1);
            ctx.fillStyle = levelFlash > 0 ? '#fff' : levelColors[levelIdx];
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            clouds.forEach(c => { ctx.fillRect(c.x, c.y, 12, 6); ctx.fillRect(c.x + 4, c.y - 4, 10, 6); });

            // Parallax Hills
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            hills.forEach(h => {
                ctx.beginPath();
                ctx.moveTo(h.x, GROUND_Y);
                ctx.lineTo(h.x + h.w/2, GROUND_Y - h.h);
                ctx.lineTo(h.x + h.w, GROUND_Y);
                ctx.fill();
            });

            ctx.fillStyle = '#3e2723'; ctx.fillRect(0, GROUND_Y, WIDTH, HEIGHT - GROUND_Y);

            // Level Progress
            if (gameState === 'PLAYING') {
                let progress = (score % 10) / 10;
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(10, HEIGHT - 8, WIDTH - 20, 4);
                ctx.fillStyle = '#fff'; ctx.fillRect(10, HEIGHT - 8, (WIDTH - 20) * progress, 4);
                if (combo > 1) drawText(`X${combo} COMBO`, WIDTH/2, 25, 7, "#ffcc00");
                if (recordFlash > 0) drawText("NEW RECORD!", WIDTH/2, 45, 10, `hsl(${frameCount*10}, 100%, 50%)`);
            }

            trail.forEach((t, i) => {
                ctx.globalAlpha = i / trail.length;
                ctx.fillStyle = `hsl(${t.hue}, 100%, 50%)`;
                ctx.fillRect(t.x - (t.w - 10) / 2, t.y + (10 - t.h), t.w, t.h);
            });
            ctx.globalAlpha = 1.0;

            particles.forEach(p => { 
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life; 
                ctx.fillRect(Math.round(p.x), Math.round(p.y), 2, 2); 
            });
            ctx.globalAlpha = 1.0;

            if (gameState === 'MENU' || gameState === 'PAUSED') {
                ctx.fillStyle = '#444'; ctx.fillRect(5, 5, 15, 15);
                drawText(musicEnabled ? "M" : "S", 12, 16, 8, "#fff");
            }

            if (gameState === 'MENU') {
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                drawText("PIXEL WEB JUMP", WIDTH/2, 30, 10);
                ctx.fillStyle = '#2ecc71'; ctx.fillRect(WIDTH/2 - 25, 45, 50, 15);
                drawText("PLAY", WIDTH/2, 55, 8, "#fff");
                drawText("TOP RUNS:", 10, 80, 6, "#ffcc00", "left");
                leaderboard.forEach((s, i) => drawText(`${i+1}.${s}`, 10, 92 + (i*9), 6, "#fff", "left"));

                let rotW = Math.abs(Math.sin(Date.now() / 300) * 12);
                let uiX = WIDTH - 35;
                if (playerImg) ctx.drawImage(playerImg, uiX + (12-rotW)/2, 85, rotW, 12);
                else { ctx.fillStyle = playerColor; ctx.fillRect(uiX + (12-rotW)/2, 85, rotW, 12); }
                ctx.fillStyle = '#444'; ctx.fillRect(uiX-10, 105, 32, 10);
                drawText("IMG", uiX+6, 112, 6);
                ctx.fillStyle = '#444'; ctx.fillRect(uiX-10, 118, 32, 10);
                drawText("COLOR", uiX+6, 125, 6);

            } else if (gameState === 'COLOR_PICKER') {
                ctx.fillStyle = 'rgba(0,0,0,0.9)'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                drawText("PICK SKIN", WIDTH/2, 30, 8);
                skinOptions.forEach((col, i) => {
                    ctx.fillStyle = col; ctx.fillRect(25 + (i*19), 60, 14, 14);
                    if(playerColor === col) { ctx.strokeStyle = '#fff'; ctx.strokeRect(25 + (i*19), 60, 14, 14); }
                });
                drawText("BACK", WIDTH/2, 110, 7, "#ffcc00");

            } else {
                let vX = player.x - (player.drawW - 10) / 2;
                let vY = player.y + (10 - player.drawH);
                if (playerImg) ctx.drawImage(playerImg, vX, vY, player.drawW, player.drawH);
                else { ctx.fillStyle = playerColor; ctx.fillRect(vX, vY, player.drawW, player.drawH); }
                
                ctx.fillStyle = '#e91e63'; 
                obstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));
                
                drawText(`SCORE:${score}`, 5, 12, 7, "#fff", "left");
                ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(WIDTH-15, 5, 10, 10);
                drawText("||", WIDTH-10, 13, 7, "#000");

                if (gameState === 'PAUSED') {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                    drawText("PAUSED", WIDTH/2, 40, 10);
                    ctx.fillStyle = '#444'; ctx.fillRect(WIDTH/2 - 25, 65, 50, 14);
                    drawText("RESUME", WIDTH/2, 74, 7);
                    ctx.fillStyle = '#444'; ctx.fillRect(WIDTH/2 - 25, 85, 50, 14);
                    drawText("QUIT", WIDTH/2, 94, 7, "#ff5555");
                }
                if (gameState === 'GAMEOVER') {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                    drawText("GAME OVER", WIDTH/2, 60, 10);
                    drawText(`FINAL SCORE: ${score}`, WIDTH/2, 75, 7, "#fff");
                    drawText("TAP TO RESTART", WIDTH/2, 95, 6, "#ffcc00");
                }
            }
        }

        function handleInput(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const tx = ((clientX - rect.left) / rect.width) * WIDTH;
            const ty = ((clientY - rect.top) / rect.height) * HEIGHT;

            if ((gameState === 'MENU' || gameState === 'PAUSED') && tx < 25 && ty < 25) {
                musicEnabled = !musicEnabled;
                if(musicEnabled) { if(audioCtx.state === 'suspended') audioCtx.resume(); startBGM(); }
                return;
            }

            if (gameState === 'MENU') {
                if (tx > WIDTH/2 - 25 && tx < WIDTH/2 + 25 && ty > 45 && ty < 60) resetGame();
                else if (tx > WIDTH - 50 && ty > 100 && ty < 115) fileInput.click();
                else if (tx > WIDTH - 50 && ty > 115) gameState = 'COLOR_PICKER';
            } else if (gameState === 'COLOR_PICKER') {
                skinOptions.forEach((col, i) => {
                    if (tx > 25+(i*19) && tx < 39+(i*19) && ty > 60 && ty < 74) {
                        playerColor = col; playerImg = null;
                        localStorage.setItem('pixelJumpColor', col);
                        localStorage.removeItem('pixelJumpImg');
                    }
                });
                if (ty > 100) gameState = 'MENU';
            } else if (gameState === 'PLAYING') {
                if (tx > WIDTH - 20 && ty < 20) gameState = 'PAUSED';
                else if (player.jumpCount < 2) {
                    player.vy = -4.2; player.jumpCount++;
                    player.drawW = 6; player.drawH = 16; 
                    playSound(150 + (player.jumpCount * 50), 400);
                    createParticles(player.x + 5, player.y + 10, '#fff', 5);
                }
            } else if (gameState === 'PAUSED') {
                if (tx > WIDTH/2 - 25 && tx < WIDTH/2 + 25 && ty > 65 && ty < 79) gameState = 'PLAYING';
                if (tx > WIDTH/2 - 25 && tx < WIDTH/2 + 25 && ty > 85 && ty < 99) gameState = 'MENU';
            } else if (gameState === 'GAMEOVER') resetGame();
        }

        window.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        
        // Added mouse support for desktop testing
        window.addEventListener('mousedown', (e) => {
            handleInput(e.clientX, e.clientY);
        });

        update();
    </script>
</body>
</html>
